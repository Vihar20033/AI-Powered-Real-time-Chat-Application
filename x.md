Okay, as an expert in MERN stack development with 10 years of experience, I'll create an Express server adhering to best practices, modularity, error handling, and scalability, using ES6 modules.\n\nWe'll set up a project structure that is clean and easy to maintain.\n\n---\n\n### Project Setup Steps\n\n1.  **Create a new directory** for your project and navigate into it:\n    ```bash\n    mkdir express-es6-server\n    cd express-es6-server\n    ```\n\n2.  **Initialize npm** and create a `package.json` file:\n    ```bash\n    npm init -y\n    ```\n\n3.  **Install necessary dependencies**:\n    ```bash\n    npm install express dotenv cors morgan\n    npm install --save-dev nodemon # For development auto-restarts\n    ```\n\n4.  **Configure `package.json` for ES6 modules**:\n    Open `package.json` and add `\"type\": \"module\"` at the top level.\n    Also, add your scripts:\n\n    ```json\n    {\n      \"name\": \"express-es6-server\",\n      \"version\": \"1.0.0\",\n      \"description\": \"An Express server with ES6 modules, following best practices.\",\n      \"main\": \"src/server.js\",\n      \"type\": \"module\",\n      \"scripts\": {\n        \"start\": \"node src/server.js\",\n        \"dev\": \"nodemon src/server.js\",\n        \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n      },\n      \"keywords\": [],\n      \"author\": \"Your Name\",\n      \"license\": \"ISC\",\n      \"dependencies\": {\n        \"cors\": \"^2.8.5\",\n        \"dotenv\": \"^16.4.5\",\n        \"express\": \"^4.19.2\",\n        \"morgan\": \"^1.10.0\"\n      },\n      \"devDependencies\": {\n        \"nodemon\": \"^3.1.0\"\n      }\n    }\n    ```\n\n5.  **Create `.env` file**:\n    This file will store your environment variables.\n    ```\n    PORT=8000\n    NODE_ENV=development\n    CORS_ORIGIN=* # In production, specify your frontend URL, e.g., http://localhost:3000\n    ```\n\n6.  **Create the project structure**:\n    ```\n    .\n    â”œâ”€â”€ .env\n    â”œâ”€â”€ package.json\n    â”œâ”€â”€ src/\n    â”‚   â”œâ”€â”€ app.js\n    â”‚   â”œâ”€â”€ server.js\n    â”‚   â”œâ”€â”€ config/\n    â”‚   â”‚   â””â”€â”€ index.js\n    â”‚   â”œâ”€â”€ middlewares/\n    â”‚   â”‚   â”œâ”€â”€ errorHandler.js\n    â”‚   â”‚   â””â”€â”€ notFound.js\n    â”‚   â”œâ”€â”€ routes/\n    â”‚   â”‚   â”œâ”€â”€ index.js\n    â”‚   â”‚   â””â”€â”€ userRoutes.js\n    â”‚   â””â”€â”€ utils/\n    â”‚       â”œâ”€â”€ ApiError.js\n    â”‚       â””â”€â”€ asyncHandler.js\n    ```\n\n---\n\n### Code Implementation\n\nNow, let's fill in the files:\n\n#### 1. `src/config/index.js`\n(Configuration for environment variables)\n\n```javascript\n// src/config/index.js\n\nimport dotenv from 'dotenv';\n\n// Load environment variables from .env file\ndotenv.config({\n    path: '.env'\n});\n\n/**\n * @namespace Config\n * @description Centralized configuration object for the application.\n *              Retrieves environment variables and provides default values.\n */\nconst config = {\n    // Port on which the server will run\n    port: process.env.PORT || 8000,\n    // Current environment (e.g., 'development', 'production', 'test')\n    env: process.env.NODE_ENV || 'development',\n    // CORS origin configuration\n    corsOrigin: process.env.CORS_ORIGIN || '*' // Be specific in production, e.g., 'http://localhost:3000'\n};\n\nexport default config;\n```\n\n#### 2. `src/utils/ApiError.js`\n(Custom Error Class for structured API errors)\n\n```javascript\n// src/utils/ApiError.js\n\n/**\n * @class ApiError\n * @extends Error\n * @description Custom error class for handling API-specific errors.\n *              Allows for structured error responses with status codes and messages.\n */\nclass ApiError extends Error {\n    /**\n     * Creates an instance of ApiError.\n     * @param {number} statusCode - The HTTP status code for the error (e.g., 400, 404, 500).\n     * @param {string} message - The error message.\n     * @param {Array<string>} [errors=[]] - An array of detailed error messages, useful for validation errors.\n     * @param {string} [stack=''] - The error stack trace.\n     */\n    constructor(\n        statusCode,\n        message = \"Something went wrong\",\n        errors = [],\n        stack = \"\"\n    ) {\n        super(message); // Call parent (Error) constructor with the message\n        this.statusCode = statusCode;\n        this.data = null; // Can be used to attach additional data if needed\n        this.message = message;\n        this.success = false; // Indicates an error response\n        this.errors = errors;\n\n        // Capture stack trace, excluding the constructor call itself\n        if (stack) {\n            this.stack = stack;\n        } else {\n            Error.captureStackTrace(this, this.constructor);\n        }\n    }\n}\n\nexport { ApiError };\n```\n\n#### 3. `src/utils/asyncHandler.js`\n(Utility for handling async route functions)\n\n```javascript\n// src/utils/asyncHandler.js\n\n/**\n * @function asyncHandler\n * @description A higher-order function to wrap asynchronous Express route handlers.\n *              It catches any errors thrown by the async function and passes them to the\n *              Express error handling middleware. This avoids writing repetitive try-catch blocks.\n * @param {Function} requestHandler - An asynchronous Express route handler function\n *                                    (req, res, next) => Promise<any>.\n * @returns {Function} An Express middleware function that executes the requestHandler\n *                     and handles any rejections.\n */\nconst asyncHandler = (requestHandler) => {\n    return (req, res, next) => {\n        // Resolve the promise returned by the requestHandler\n        // If it resolves, fine. If it rejects, catch the error and pass it to next()\n        Promise.resolve(requestHandler(req, res, next)).catch((err) => next(err));\n    };\n};\n\nexport { asyncHandler };\n```\n\n#### 4. `src/middlewares/notFound.js`\n(Middleware for handling 404 Not Found errors)\n\n```javascript\n// src/middlewares/notFound.js\n\nimport { ApiError } from '../utils/ApiError.js';\n\n/**\n * @function notFoundHandler\n * @description Middleware to handle requests to undefined routes (404 Not Found).\n *              It creates an ApiError with status 404 and passes it to the next middleware.\n * @param {object} req - Express request object.\n * @param {object} res - Express response object.\n * @param {function} next - Express next middleware function.\n */\nconst notFoundHandler = (req, res, next) => {\n    // Create a new ApiError for 404 Not Found\n    const error = new ApiError(404, `Not Found - ${req.originalUrl}`);\n    // Pass the error to the next middleware (which should be the global error handler)\n    next(error);\n};\n\nexport { notFoundHandler };\n```\n\n#### 5. `src/middlewares/errorHandler.js`\n(Global Error Handling Middleware)\n\n```javascript\n// src/middlewares/errorHandler.js\n\nimport { ApiError } from '../utils/ApiError.js';\nimport config from '../config/index.js';\n\n/**\n * @function errorHandler\n * @description Global error handling middleware for Express.\n *              It catches errors passed from routes or other middlewares and formats\n *              the response consistently. It distinguishes between operational errors (ApiError)\n *              and programming errors.\n * @param {Error} err - The error object.\n * @param {object} req - Express request object.\n * @param {object} res - Express response object.\n * @param {function} next - Express next middleware function (not used in the final error handler).\n */\nconst errorHandler = (err, req, res, next) => {\n    // Determine the status code and message.\n    // Default to 500 Internal Server Error if not an ApiError.\n    let statusCode = err.statusCode || 500;\n    let message = err.message || \"Internal Server Error\";\n    let errors = err.errors || [];\n\n    // If the error is not an instance of ApiError, it's an unexpected error.\n    // In production, we might want to hide internal error details.\n    if (!(err instanceof ApiError)) {\n        // Log the full error for debugging in development/staging\n        if (config.env === 'development') {\n            console.error('UNEXPECTED ERROR:', err);\n        }\n        // Generalize message for non-operational errors\n        message = \"Something went wrong!\";\n        statusCode = 500; // Ensure 500 for unexpected errors\n        errors = []; // Clear detailed errors for unexpected errors\n    } else {\n        // If it's an ApiError, it's an operational error.\n        // We can safely expose its message and details.\n        console.warn(`API Error [${statusCode}]: ${message}`, errors);\n    }\n\n    // Send the error response\n    res.status(statusCode).json({\n        success: false,\n        message,\n        errors: config.env === 'development' ? err.errors : undefined, // Only show specific errors in dev\n        stack: config.env === 'development' ? err.stack : undefined // Only show stack in development\n    });\n};\n\nexport { errorHandler };\n```\n\n#### 6. `src/routes/userRoutes.js`\n(Example User Routes)\n\n```javascript\n// src/routes/userRoutes.js\n\nimport { Router } from 'express';\nimport { asyncHandler } from '../utils/asyncHandler.js';\nimport { ApiError } from '../utils/ApiError.js';\n\nconst router = Router();\n\n/**\n * @route GET /api/v1/users\n * @description Get all users.\n *              Demonstrates an async handler and a successful response.\n */\nrouter.get(\"/\", asyncHandler(async (req, res) => {\n    // Simulate fetching users from a database\n    const users = [\n        { id: 1, name: \"Alice\", email: \"alice@example.com\" },\n        { id: 2, name: \"Bob\", email: \"bob@example.com\" }\n    ];\n\n    // Simulate a delay for async operation\n    await new Promise(resolve => setTimeout(resolve, 500));\n\n    res.status(200).json({\n        success: true,\n        message: \"Users fetched successfully\",\n        data: users\n    });\n}));\n\n/**\n * @route GET /api/v1/users/:id\n * @description Get a single user by ID.\n *              Demonstrates handling a not-found scenario with ApiError.\n */\nrouter.get(\"/:id\", asyncHandler(async (req, res, next) => {\n    const userId = parseInt(req.params.id);\n\n    // Simulate fetching a user by ID\n    await new Promise(resolve => setTimeout(resolve, 300));\n\n    if (userId === 1) {\n        res.status(200).json({\n            success: true,\n            message: \"User fetched successfully\",\n            data: { id: 1, name: \"Alice\", email: \"alice@example.com\" }\n        });\n    } else if (userId === 999) {\n        // Simulate a programming error (this should be caught by asyncHandler)\n        throw new Error(\"Simulated unexpected database error for ID 999!\");\n    }\n    else {\n        // If user not found, throw an ApiError\n        throw new ApiError(404, `User with ID ${userId} not found`);\n    }\n}));\n\n/**\n * @route POST /api/v1/users\n * @description Create a new user.\n *              Demonstrates accessing request body and throwing validation errors.\n */\nrouter.post(\"/\", asyncHandler(async (req, res, next) => {\n    const { name, email } = req.body;\n\n    if (!name || !email) {\n        throw new ApiError(400, \"Name and email are required for creating a user.\", [\"name is missing\", \"email is missing\"]);\n    }\n\n    // Simulate saving user to a database\n    await new Promise(resolve => setTimeout(resolve, 400));\n    const newUser = { id: Math.floor(Math.random() * 1000) + 3, name, email };\n\n    res.status(201).json({\n        success: true,\n        message: \"User created successfully\",\n        data: newUser\n    });\n}));\n\nexport default router;\n```\n\n#### 7. `src/routes/index.js`\n(Aggregator for all API routes)\n\n```javascript\n// src/routes/index.js\n\nimport { Router } from 'express';\nimport userRoutes from './userRoutes.js';\n\nconst router = Router();\n\n/**\n * @description Define API version 1 routes.\n *              All routes under /api/v1 will be defined here.\n */\nrouter.use('/users', userRoutes);\n\n// You can add more routes here, e.g.:\n// router.use('/products', productRoutes);\n// router.use('/orders', orderRoutes);\n\nexport default router;\n```\n\n#### 8. `src/app.js`\n(Express application setup and middleware)\n\n```javascript\n// src/app.js\n\nimport express from 'express';\nimport cors from 'cors';\nimport morgan from 'morgan';\nimport config from './config/index.js';\nimport apiRoutes from './routes/index.js';\nimport { notFoundHandler } from './middlewares/notFound.js';\nimport { errorHandler } from './middlewares/errorHandler.js';\n\n// Initialize Express application\nconst app = express();\n\n/**\n * @description Global Middlewares\n *              These middlewares are applied to every incoming request.\n */\n\n// 1. CORS Middleware: Enables Cross-Origin Resource Sharing.\n//    Configured to allow requests from the specified origin or all origins in development.\napp.use(cors({\n    origin: config.corsOrigin, // Allow requests from this origin\n    credentials: true // Allow sending cookies and authorization headers\n}));\n\n// 2. Body Parser (JSON): Parses incoming JSON requests and puts the parsed data in `req.body`.\napp.use(express.json({\n    limit: \"16kb\" // Limit JSON payload size\n}));\n\n// 3. Body Parser (URL-encoded): Parses incoming URL-encoded data (e.g., from HTML forms).\n//    `extended: true` allows for rich objects and arrays to be encoded into the URL-encoded format.\napp.use(express.urlencoded({\n    extended: true,\n    limit: \"16kb\" // Limit URL-encoded payload size\n}));\n\n// 4. Static Files: Serves static files from the 'public' directory.\n//    Useful for serving frontend build or static assets (e.g., images, CSS).\napp.use(express.static(\"public\"));\n\n// 5. Morgan Logger: Logs HTTP requests to the console.\n//    'dev' format provides a concise, color-coded output suitable for development.\n//    Only enable in development environment for better performance in production.\nif (config.env === 'development') {\n    app.use(morgan('dev'));\n}\n\n/**\n * @description Route Handlers\n *              Mount specific routes for API endpoints.\n */\n\n// Health check route\napp.get('/health', (req, res) => {\n    res.status(200).json({\n        success: true,\n        message: 'Server is healthy!'\n    });\n});\n\n// API Version 1 routes\n// All routes defined in `src/routes/index.js` will be prefixed with `/api/v1`.\napp.use('/api/v1', apiRoutes);\n\n/**\n * @description Error Handling Middlewares\n *              These middlewares are placed at the end of the middleware stack\n *              to catch any errors that occur during request processing.\n */\n\n// 1. Not Found Handler: Catches all requests that didn't match any route\n//    and forwards them as a 404 error.\napp.use(notFoundHandler);\n\n// 2. Global Error Handler: Processes any errors passed via `next(err)`.\n//    This should be the last middleware.\napp.use(errorHandler);\n\nexport { app };\n```\n\n#### 9. `src/server.js`\n(Server startup file)\n\n```javascript\n// src/server.js\n\nimport { app } from './app.js';\nimport config from './config/index.js';\n\n/**\n * @description Main server entry point.\n *              Starts the Express server and handles initial connection logging.\n */\n\n// Define the port from our configuration\nconst PORT = config.port;\n\n// Start the Express server\napp.listen(PORT, () => {\n    console.log(`ðŸš€ Server is running in ${config.env} mode on port ${PORT}`);\n    console.log(`ðŸ”— Access the server at http://localhost:${PORT}`);\n});\n\n// Handle unhandled promise rejections (e.g., database connection issues not caught)\nprocess.on('unhandledRejection', (err) => {\n    console.error('UNHANDLED REJECTION! ðŸ’¥ Shutting down...');\n    console.error(err.name, err.message);\n    // Optionally, perform cleanup or gracefully exit\n    process.exit(1);\n});\n\n// Handle uncaught exceptions (e.g., synchronous code errors not caught)\nprocess.on('uncaughtException', (err) => {\n    console.error('UNCAUGHT EXCEPTION! ðŸ’¥ Shutting down...');\n    console.error(err.name, err.message);\n    // Optionally, perform cleanup or gracefully exit\n    process.exit(1);\n});\n```\n\n---\n\n### How to Run\n\n1.  **Open your terminal** in the `express-es6-server` directory.\n2.  **Start the server in development mode**:\n    ```bash\n    npm run dev\n    ```\n    This will use `nodemon` to automatically restart the server on code changes.\n3.  **To run in production mode** (without nodemon):\n    ```bash\n    npm start\n    ```\n\n### Test the API (using tools like Postman, Insomnia, or browser)\n\n*   **Health Check**:\n    `GET http://localhost:8000/health`\n    *Expected: `{\"success\":true,\"message\":\"Server is healthy!\"}`*\n\n*   **Get All Users**:\n    `GET http://localhost:8000/api/v1/users`\n    *Expected: A list of users.*\n\n*   **Get User by ID (Found)**:\n    `GET http://localhost:8000/api/v1/users/1`\n    *Expected: User with ID 1.*\n\n*   **Get User by ID (Not Found)**:\n    `GET http://localhost:8000/api/v1/users/99`\n    *Expected: `{\"success\":false,\"message\":\"User with ID 99 not found\"}` with status 404.*\n\n*   **Simulate unexpected error**:\n    `GET http://localhost:8000/api/v1/users/999`\n    *Expected: `{\"success\":false,\"message\":\"Something went wrong!\"}` with status 500 (and stack/detailed errors in development).*\n\n*   **Create User (Success)**:\n    `POST http://localhost:8000/api/v1/users`\n    Body (JSON):\n    ```json\n    {\n        \"name\": \"Charlie\",\n        \"email\": \"charlie@example.com\"\n    }\n    ```\n    *Expected: Created user object with status 201.*\n\n*   **Create User (Validation Error)**:\n    `POST http://localhost:8000/api/v1/users`\n    Body (JSON):\n    ```json\n    {\n        \"name\": \"David\"\n    }\n    ```\n    *Expected: `{\"success\":false,\"message\":\"Name and email are required for creating a user.\",\"errors\":[\"name is missing\",\"email is missing\"]}` with status 400.*\n\n*   **Access Non-existent Route**:\n    `GET http://localhost:8000/api/v1/non-existent-route`\n    *Expected: `{\"success\":false,\"message\":\"Not Found - /api/v1/non-existent-route\"}` with status 404.*\n\n---\n\nThis setup provides a robust, scalable, and maintainable foundation for your Express.js applications using modern ES6 syntax and best practices. Error handling is centralized, configuration is externalized, and routes are modularized.